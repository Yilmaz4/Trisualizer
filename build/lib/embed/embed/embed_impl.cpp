// File generated using battery::embed (https://github.com/batterycenter/embed)
// DO NOT EDIT THIS FILE!!!

#include "battery/embed.hpp"

#if !defined(B_PRODUCTION_MODE) && !defined(B_OS_WEB)
#include <codecvt>
#include <thread>
#include <filesystem>
#include <fstream>
#include <mutex>
#include <unordered_map>
#include <optional>
#endif // !B_PRODUCTION_MODE and !B_OS_WEB

namespace b {
    
#if !defined(B_PRODUCTION_MODE) && !defined(B_OS_WEB)

    // All this crazyness is necessary because we need to use std::string_view because of constexpr,
    // and the string_view only points to a char array, so we need a string that outlives 
    // the string_view it is assigned to.

    struct FileData {
        std::string filename;
        std::string newContent;
        std::string filepath;
        std::filesystem::file_time_type lastWriteTime;
        std::function<void(const b::EmbedInternal::EmbeddedFile&)> callback;
    };

    static std::mutex embeddedFilesMapMutex;
    static std::unordered_map<std::string,FileData> embeddedFiles;
   
#ifdef _WIN32
#ifdef __clang__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

    static std::wstring embed_widen(const std::string& str) {
        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
        return converter.from_bytes(str);
    }
    
#ifdef __clang__
#pragma GCC diagnostic pop
#endif

#endif // _WIN32

    static std::optional<std::string> embed_read_file(const std::string_view& filename) {
#ifdef _WIN32
        std::ifstream file(embed_widen(std::string(filename)).c_str(), std::ios::binary);
#else // _WIN32
        std::ifstream file(std::string(filename), std::ios::binary);
#endif // _WIN32
        if (file.fail()) {
            return {};
        }
        return std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    }

    // Apple-Clang does not support std::jthread yet, hence we make our own version of jthread here:
    class AutoThread {
    public:
        template<typename Tfunc>
        AutoThread(Tfunc&& function)
            : m_thread([&]() { function(m_shouldStop); }) 
        {}
        
        ~AutoThread() {
            m_shouldStop = true;
            m_thread.join();
        }

        AutoThread(const AutoThread& other) = delete;
        AutoThread(AutoThread&& other) = delete;
        AutoThread& operator=(const AutoThread& other) = delete;
        AutoThread& operator=(AutoThread&& other) = delete;

    private:
        std::thread m_thread;
        std::atomic<bool> m_shouldStop = false;
    };

    // This is a global file watcher thread that is created at program start and automatically destroyed at program end
    // All embedded files are hot-reloaded by this thread.
    AutoThread embeddedFileWatcherThread = AutoThread([](std::atomic<bool>& shouldStop) {
        while (!shouldStop) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::lock_guard<std::mutex> lock(embeddedFilesMapMutex);
            for (auto& [key, filedata] : embeddedFiles) {
                std::filesystem::path filepath(key);
                std::error_code ec;
                auto newWriteTime = std::filesystem::last_write_time(filepath, ec);
                if (!ec) {
                    if (newWriteTime != filedata.lastWriteTime) {
                        filedata.lastWriteTime = newWriteTime;
                        auto fileresult = embed_read_file(key);
                        if (!fileresult) {
                            continue;
                        }
                        filedata.newContent = *fileresult;
                        EmbedInternal::EmbeddedFile newFile(filedata.newContent, filedata.filename, filedata.filepath);
                        filedata.callback(newFile);
                    }
                }
            }
        }
    });

#endif // !B_PRODUCTION_MODE and !B_OS_WEB

    void EmbedInternal::EmbeddedFile::get(const std::function<void(const b::EmbedInternal::EmbeddedFile&)>& callback) {
#if defined(B_PRODUCTION_MODE) || defined(B_OS_WEB)
        callback(*this);
#else // B_PRODUCTION_MODE or B_OS_WEB
        auto fileresult = embed_read_file(m_fullFilepath);
        if (fileresult) {
            m_data = *fileresult;
        }
        callback(*this);

        FileData fileData;
        fileData.filename = m_filename;
        fileData.newContent = m_data;
        fileData.filepath = m_fullFilepath;
        fileData.callback = callback;
        fileData.lastWriteTime = std::filesystem::last_write_time(m_fullFilepath);

        std::lock_guard<std::mutex> lock(embeddedFilesMapMutex);
        embeddedFiles[std::string(m_fullFilepath)] = fileData;
#endif // B_PRODUCTION_MODE or B_OS_WEB
    }

} // namespace b
